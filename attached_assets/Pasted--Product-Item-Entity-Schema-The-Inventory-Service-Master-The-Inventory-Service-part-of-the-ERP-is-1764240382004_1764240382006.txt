 Product/Item Entity Schema (The Inventory Service Master)The Inventory Service (part of the ERP) is the master for all static product information (Item Master Data) and dynamic stock levels. Other services (CRM Sales, Finance) only replicate the essential fields they need.1. Inventory Service (Master Data)This dedicated Django service holds the complete, authoritative record for every item the business sells or purchases.Field NameData TypeDescriptionitem_uuidUUID (Primary Key)Unique identifier. Used by all other services for referencing this product.skuString (Unique)Stock Keeping Unit. The primary, human-readable ID.nameStringMarketing name of the product.descriptionTextDetailed product description.unit_of_measureChoicee.g., 'EA' (Each), 'KG', 'BOX', 'HOUR'.typeChoicee.g., 'Finished Good', 'Raw Material', 'Service'.statusChoicee.g., 'Active', 'Discontinued', 'Draft'.standard_costDecimalThe average or standard cost of the item (for Finance).sales_priceDecimalDefault selling price (can be overridden by Sales/Quote service).is_taxableBooleanLegal flag for tax calculation.2. CRM Sales Service (Local Replica)The Sales Service replicates only the necessary fields to create a Quote or Sales Order Line Item.Field NameData TypePurposeSourceitem_uuidUUID (Foreign Key)Links to the master record.Inventory ServiceskuStringFor display on quotes and searching.Inventory ServicenameStringFor display on quotes.Inventory Servicesales_priceDecimalFor calculating quote totals.Inventory Serviceis_availableBooleanReal-time stock flag. Updated by API call to Inventory Service.Inventory Service3. Synchronization Flow: Eventual ConsistencyCreation/Update: A Product Manager updates the sales_price in the Inventory Service.Event: The Inventory Service publishes a PRODUCT_UPDATED event to the Message Broker (RabbitMQ/Redis).Consumption: A Celery worker in the Sales Service consumes this event and updates its local replica of the sales_price for that item_uuid.This ensures loose coupling. The Sales Service doesn't rely on the Inventory Service being available to view product names, only to check stock.ðŸ’» II. Django REST Framework API DesignWe'll use Django REST Framework (DRF) to define the clear, contract-driven APIs for inter-service communication. Each API should be secured using JWT (from the Auth Service) and focused on its specific domain.A. Contact Service APIs (Master Data)Base URL: /api/v1/contactsEndpointMethodDRF ViewPurposeAuth/accounts/POSTAccountViewSetCreate a new customer/account.IsAuthenticated (Internal)/accounts/{uuid}GETAccountViewSetRead/Retrieve the full 360Â° Account master data.IsAuthenticated (Internal/Gateway)/accounts/{uuid}PUTAccountViewSetUpdate master data (e.g., address). Fires ACCOUNT_UPDATED event.IsAuthenticated (Internal)/searchGETAccountSearchAPIViewSearch accounts by name, phone, or email.IsAuthenticated (Gateway)B. Inventory Service APIs (Master Data & Stock Check)Base URL: /api/v1/inventoryEndpointMethodDRF ViewPurposeAuth/products/POSTProductViewSetCreate a new product. Fires PRODUCT_CREATED event.IsAuthenticated (Internal)/products/{uuid}GETProductViewSetRetrieve product master data.IsAuthenticated (Gateway)/stock/{uuid}/checkGETStockCheckAPIViewSynchronous check: Returns current quantity_available and is_available boolean. CRITICAL for Sales/Order.IsAuthenticated (Internal/Gateway)/transactions/POSTStockTransactionViewSetRecord a stock change (e.g., received goods). Fires STOCK_UPDATED event.IsAuthenticated (Internal)By using DRF ViewSets, you benefit from built-in serialization, validation, and CRUD operations, accelerating your development. The key architectural decision is always: Which service owns the data, and should the communication be synchronous (API call) or asynchronous (Celery event)?